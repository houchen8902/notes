## 单继承
`class <派生类名>: <继承方式> <基类名> {};`  

```
class A {};
class B: public A {};
```

## 多继承
`class <派生类名>: <继承方式1> <基类名1>, <继承方式2> <基类名2>, ... {};`  

```
class A {};
class B {};
class C: public A, public B {};
```

## 访问修饰符
基类可以用`public`、`protected`、`private`修饰，一般用`public`。  

**公有继承(public)：** 当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。  

**保护继承(protected)：** 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。  

**私有继承(private)：** 当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。  

###### 基类的下列函数派生类不能继承:
- 基类的构造函数、析构函数和拷贝构造函数
- 基类的重载运算符
- 基类的友元函数

## 私有成员访问权限和私有继承
继承之前，父类原私有成员，无论是私有继承还是公共继承，无论是直接引用，还是使用父类命名空间引用，子类都无权访问。  

私有继承时，父类原公有成员或保护成员，子类先继承过来，然后再设置权限为私有。这样，在子类代码中，可以访问这些成员。但子类的对象和子类的子类不可以访问这些成员。  

## 虚拟继承
```
class D {};
class A: public D {};
class B: public D {};
class C: public A, public B {};
```
这样的继承，会使C类创建对象时生成两次D类对象，要解决这个问题，基类需要虚拟继承：  
`class 类名: virtual 继承方式 基类名`  

```
class D {};
class A: virtual public D {};
class B: virtual public D {};
class C: public A, public B {};
```
令基类A、B虚拟继承D，则C创建对象时，D、A、B都只生成一次对象。

## 多继承二义性

```
class A {
    void f() { }
    void g() { }
};
class B {
    void f() { }
    void h() { }
};
class C: public A, public B {
    void h() { }
};
int main() {
    C c;
    c.f();
}
```

上面的代码，当`c.f();`调用时，因为不清楚是调用哪个父类的方法，编译时会产生二义性错误。解决这个问题有两种办法：  

**一、调用时指定类名作用域**  
```
c.A::fun();
```

**二、子类覆写父类方法，在覆写中指定父类作用域**  
```
class C: public A, public B {
    void f() {
        A::f();
    }
};

c.fun();
```
