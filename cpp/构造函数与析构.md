
## 构造函数执行顺序规则
- 创建类的对象时，根据对象是否带有参数，调用类相应的构造函数
- 如果类有父类，先调用父类的构造函数
- 如果类的成员属性中有对象定义，先按声明顺序执行这些对象对应的构造函数，然后再执行本类的构造函数
- 构造函数的执行分为两个阶段，初始化阶段和计算阶段，初始化阶段先于计算阶段。所有类类型的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。计算阶段一般用于执行构造函数体内的赋值操作。

## 成员初始化列表
``` Java
/**
* 普通类
*/
class Color
{
public:
    int color;
};

/**
* 没有默认构造函数的类
*/
class Shape
{
public:
    int shape;
    Shape(int s)
    {
        shape = s;
    }
};

class Box
{
private:
    const int length;
    int width;
    int height;
    Color color;
    Shape shape;

public:
    Box(int l, int w, int h, Color c, Shape s): length(l), color(c), shape(s)
    {
        width = w;
        height = h;
    }
};
```
构造函数执行分为初始化和计算两个阶段，初始化先于计算。初始化时所有类类型成员都会初始化，所以以下情况需要在初始化阶段为成员赋值，即使用成员列表初始化：
- 为类类型成员赋值。如果在计算阶段才为类类型成员赋值，之前初始化阶段成员使用默认构造函数的初始化操作多余，浪费性能。
- 常量成员。因为常量成员只能初始化，不能赋值，所以必须放在初始化列表中。
- 没有默认构造函数的类类型。因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接赋值初始化。
- 引用类型。引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面。

成员初始化列表的执行顺序按类声明中成员定义顺序执行。  
成员初始化列表中初始化类类型成员变量的顺序没有意义，因为在构造函数调用之前，用于初始化的对象已经生成，构造函数已经调用，而且在初始化列表中为类类型成员变量赋值时，不会再调用这些类的构造函数。  

为提高性能，尽量在成员列表中初始化。  

子类如果想显式调用父类的有参数构造函数，需要在成员初始化列表中调用。生成的对象仍然是本对象，只是不再通过调用默认无参构造函数的方式实现，而且执行先于本构造函数的函数体。  


## 析构函数
- 析构函数只有一个，不能重载
- 在对象撤销时析构函数自动被调用，也可显式调用。显式调用析构函数，使用`对象名.~类名();`
- 默认析构函数无法自动释放`new`、`malloc`申请的空间，需要自定义析构函数手动释放
- 使用`new`生成的对象，保存在栈内存或堆内存中，当调用`delete`删除内存时，析构函数自动执行
- 如果创建的是静态存储类对象，其析构函数在程序结束时执行
- 如果创建的对象是在栈中的，其析构函数在代码块结束时自动执行，先调用栈顶对象(也就是后创建对象)的析构函数
- 手动调用构函数函数后，在程序结束执行时，析构函数仍会自动执行。
- 析构函数调用时，先调用子类析构函数，后调用父类析构函数
- 子类对象的父类析构函数执行时，如果父类析构函数调用了虚方法，且子类中对虚方法有实现，仍执行父类中虚方法的实现
- 父类对象析构函数执行时，调用父类虚方法，且虚方法在子类有实现时，仍调用父类虚方法实现

## 私有化析构函数
当分配在栈中的对象离开作用域，或者分配在堆中的对象被delete时，类的公共析构函数会被调用。  

如果类的析构函数被定义为私有的，则类不能在栈中实现对象，也不能对堆中分配的对象直接delete，否则报错。可以在类中再定义一个方法，用来删除堆中对象，因为类中方法可以调用私有析构函数。  

总结：私有化析构函数，可以保证类的对象只能在堆中实现。  

``` cpp
class A {
public:
    void destroy() {
        delete this;
    }
private:
    ~A() {}
}
```

## 临时对象
```
class A {
private:
    int m_age;
public:
    A(int age) { m_age = age; }
}

A a2 = A(24);   // a2不存在，右侧生成对象并初始化，然后赋给a2
a2 = A(25);    // 生成临时对象，把对象赋值给a2，再调用临时对象的析构函数
```
当a2对象不存在时，`类名()`是生成对象并初始化；当a2对象存在时，`类名()`是生成临时对象，赋值给a2对象，然后自动销毁临时对象。

## 复制构造函数

```
A(const A& a) { }    // 复制构造函数定义

A a;
A a1 = a;    // 初始化，调用复制构造函数，a为构造函数中的参数，a1为构造函数生成的对象
A a2(a);     // 初始化，调用复制构造函数，a为构造函数中的参数，a2为构造函数生成的对象

void fun(A a1) { }
fun(a2);             // 调用复制构造函数，使用a2生成a1

A fun() { A a; return a; }
fun().print();       // 函数返回对象时，调用复制构造函数，使用a生成返回值对象
```

只有一个参数，即同类对象的引用，形如`A(const A&)`。只能是对象的引用，不能是对象。  

如果没有定义复制构造函数，编译器自动生成默认复制构造函数，默认复制构造函数完成复制功能。如果定义了复制构造函数，默认复制构造函数不再存在。  

复制构造函数的参数为类本身对象的引用，用于根据一个已存在的对象复制出一个本类的新对象。当类中存在指针成员时，使用默认复制构造函数会存在风险。  

复制构造函数中可以直接使用参数对象的私有成员。  

复制构造函数有三种用途：  

一：用一个对象去初始化同类的另一个对象：  
初始化有两种方法，分别是`A a1(a);`和`A a2 = a;`。此时，会调用复制构造函数，a为构造函数的形参，a1和a2为构造函数生成的对象，不会生成临时对象。`A a1, a2; a1 = a2;`是赋值语句，复制操作，不是初始化操作，不会调用复制构造函数。  

当用子类对象初始化父类对象时，调用父类复制构造函数。  

二：函数参数为对象时：  
如果某函数的参数是类A的对象，当函数被调用时，类A的复制构造函数将会被调用来生成和初始化函数形参。在这里，复制构造函数是实参对象和函数形参对象之间的桥梁，在复制构造函数中，参数是实参对象，生成的对象是函数的形参。  

对象作为运算符重载方法的参数时，也会调用复制构造函数，如果没有提供复制构造函数，会自动调用默认复制构造函数。  

三：函数返回值是对象时：  
当函数返回对象时，会调用对象类的复制构造函数，使用函数内返回的对象，生成函数返回值对象。  

## 类型转换构造函数

```
A(int i) { }

A a1;
A a2 = 9;    // 初始化语句，会调用类型转换构造函数以9为参数进行初始化，不会生成临时对象
a1 = 12;     // 12被转换为一个临时对象，然后赋值给a1
```

## 默认构造函数

编译器默认为类生成一个默认构造函数。如果自定义了任何一个构造函数，则不再有默认构造函数。如果此时仍想有默认构造函数，声明如下，函数体可自定义：  
```
A(void) {}
```
