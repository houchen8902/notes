
# 指针

每一个变量都有一个内存位置，对应一个地址，该地址可以通过取地址运算符 `&` 获得。  

```
int var = 1;
cout << "address is " << &var << endl;
```

## 什么是指针

指针是一个变量，用于存储其它变量的地址。  

像其它变量一样，在使用指针存储其它变量地址之前，必须对其进行声明，声明形式如下：  

```
type *var_name;
```

星号 `*` ，在声明时，表示一个变量是指针；在其它表达式中，`*var_name`表示取出内存地址处的变量值，变量类型为指针定义时对应的类型；`*var_name`还可用于为指定地址的变量赋值；  

所有指针的值的实际数据类型，都是一个代表内存地址的十六进制长整数，不同数据类型指针之间唯一的不同是，指针指向的变量的数据类型不同。  

## 指针的操作

指针的操作包括：声明指针变量、取变量地址，把变量地址赋值给指针变量，访问指针变量中可用地址的值。  

```
int var = 20;
int *p;           // 声明指针变量；存储一个整形变量的地址
p = &var;         // 取出变量地址，并赋值给指针变量
int *q = &var;    // 指针变量可以在声明的同时赋值
cout << *p;       // 访问指针变量中地址对应的变量值，取出变量值的类型为指针变量声明时的类型
```

## NULL

`NULL` 是一个定义在标准库中的值为 `0` 的常量。  

未初始化的指针，有时候会存储一些垃圾值，导致程序出错(在mac上运行时，未初始化指针总是==0)。所以在指针变量声明时，如果没有确切地址可以赋值，为指针变量赋一个 `NULL` 值是一个良好的编程习惯，值为 `NULL` 的指针称为`空指针`。然后，在使用指针时避免使用空指针，就可以防止误用未初始化的指针。  

在大多数操作系统中，程序不允许访问地址为0的内存，因为该内存是操作系统保留的。按照惯例，如果指针值为0，表示它不指向任何变量。  

C++中，`0`表示`false`，`!0`、`非0整数`、`字符`、`字符串`都表示`true`。所以值为`0`的指针也表示`false`，因而可以用`if`直接判断指针是否可用。  

```
if (ptr) { // 指针不为0时进入 }
if (!ptr) { // 指针为0时进入 }
```

## 指针的运算

指针中存储的是变量的地址，可以对指针执行四种算法运算： `++`、`--`、`+`、`-`  

指针每增加一次，它都会指向下一个变量位置。如：指向32位整形的指针每增加一次，它存储的地址值都会加4，指向下一个整形的位置；指向字符变量的指针每增加一次，它存储的地址值都会加1，指向下一个字符地址的位置。  

注意：指针变量加1 != 地址加1  

指针可以用关系运算符进行比较： `==`、`>`、`<`、`>=`、`<=`

## 数组

数组是一个常量指针，指向地址不变。声明一个指针，指向数组，用指针代替数组，利用指针可以加减，可以更方便地操作数组。  

```
int var[3] = {1, 2, 3};
int *ptr = var;
int *qtr = &var[2];

for (int i = 0; i < 3; i++) {
    cout << *ptr << endl;
    ptr++;
}

for (int i = 0; i < 3; i++) {
    cout << *qtr << endl;
    qtr--;
}

while (ptr <= &var[2]) {
    cout << *ptr << endl;
    ptr++;
}
```

## 指针数组

```
int var[3] = {1, 2, 3};
int *ptr[3];
for (int i = 0; i < 3; i++) {
    ptr[i] = &var[i];
}
for (int i = 0; i < 3; i++) {
    cout << *ptr[i] << endl;
}

char *names[3] = {"Zara", "Hina", "Nuha"};
for (int i = 0; i < 3; i++) {
    cout << name[i] << endl;
}
```

可以用字符串常量数组直接对字符指针数组进行初始化。  

## 字符指针

```
char sex = 'M';
char *ptr = &sex;
cout << "p = " << p << endl;      // M
cout << "*p = " << *p << endl;    // M

const char *q = "hello";
cout << "q = " << q << endl;      // hello
cout << "*q = " << *q << endl;    // h

char arr[10] = "world";
cout << arr << endl;              // world

// char array[10];
// array = "world";                    // error! 数组指针是常量，不能赋值
```

字符指针，可以用字符变量的地址赋值，也可以用字符串常量赋值。  

当用字符变量地址赋值时，`p`和`*p`的值都是字符变量的值。  

当用字符串常量赋值时，实际是把字符串常量的地址赋值给了字符指针，打印字符指针时会输出字符串常量的值，打印`*ptr`时会输出字符串常量第一个字母。因为字符串是常量，所以，赋值给字符指针时，要求字符指针是常量，否则编译时会报`warn`。同理，字符串常量可以对字符数组初始化，就是把字符串常量的地址赋给了数组指针。  


## 指向指针的指针

当定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。  

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。  

```
int **var;
```

当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符。

```
int var;
int *ptr;
int **pptr;

var = 3000;
ptr = &var;
pptr = &ptr;

cout << var << endl;
cout << *ptr << endl;
cout << **pptr << endl;
```


## 传递指针给函数

C++ 允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。调用函数时需要传入变量地址或数组名。  

```
void getSeconds( long *par ) {
    // ...
}

int main() {
    long sec = 1325131431123;
    getSeconds( &sec );
}
```

当形参为指针，实参可以为数组，此时，形参可作为数组使用。  

```
void getAverage( int *arr, int size ) {
    for (int i = 0; i < size; i++) {
        arr[i] = 1;
    }
}

int main() {
    int array[5] = {1, 2, 3, 4, 5};
    getAverage( array, 5 );
}
```


## 从函数返回指针

不允许从函数返回局部变量的地址，除非局部变量为 `static` 变量。  

c++允许从函数返回数组和指针。  

```
int * getRandom() {
    static int arr[3] = {1, 2, 3};
    return arr;
}
```

